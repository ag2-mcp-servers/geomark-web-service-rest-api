# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:13:42+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Path, Query
from starlette.requests import Request

from models import (
    AllowOverlap,
    BufferCap,
    BufferJoin,
    FileFormatExtension,
    ResultFormat,
    Srid,
)

app = MCPProxy(
    contact={
        'name': 'Contact DataBC',
        'url': 'https://dpdd.atlassian.net/servicedesk/customer/portal/1/group/7/',
    },
    description='The Geomark Web Service allows you to create and share geographic areas of interest over the web in a variety of formats and coordinate systems. This service is especially helpful when you need to share an area of interest with people who require that the data be in a different format, or they use different mapping software. \n\nPlease note that you may experience issues when submitting requests to the delivery or test environment if using this [OpenAPI specification](https://github.com/bcgov/api-specs/tree/master/geomark) in other API console viewers.',
    license={
        'name': 'Open Government License - British Columbia',
        'url': 'https://www2.gov.bc.ca/gov/content?id=A519A56BC2BF44E4A008B33FCF527F61',
    },
    termsOfService='https://www2.gov.bc.ca/gov/content?id=D1EE0A405E584363B205CD4353E02C88',
    title='GeoMark Web Service REST API',
    version='4.1.2',
    servers=[
        {'description': 'Production', 'url': 'https://apps.gov.bc.ca/pub/geomark'},
        {'description': 'Test', 'url': 'https://test.apps.gov.bc.ca/pub/geomark'},
        {
            'description': 'Delivery',
            'url': 'https://delivery.apps.gov.bc.ca/pub/geomark',
        },
    ],
)


@app.post(
    '/geomarks/copy',
    description=""" The source geomarks can be specified by with the geomarkUrl parameter.  Repeat the parameter if sourcing from multiple geomarks """,
    tags=['geomark_creation'],
)
def post_geomarks_copy(
    geomark_url: str = Query(..., alias='geomarkUrl'),
    result_format: Optional[ResultFormat] = Query(None, alias='resultFormat'),
    allow_overlap: Optional[AllowOverlap] = Query(False, alias='allowOverlap'),
    callback: Optional[str] = None,
    redirect_url: Optional[str] = Query(None, alias='redirectUrl'),
    failure_redirect_url: Optional[str] = Query(None, alias='failureRedirectUrl'),
    buffer_metres: Optional[int] = Query(None, alias='bufferMetres'),
    buffer_join: Optional[BufferJoin] = Query('ROUND', alias='bufferJoin'),
    buffer_cap: Optional[BufferCap] = Query('ROUND', alias='bufferCap'),
    buffer_mitre_limit: Optional[int] = Query(5, alias='bufferMitreLimit'),
    buffer_segments: Optional[int] = Query(8, alias='bufferSegments'),
):
    """
    Create a new geomark by copying the geometries from one or more existing geomarks from the current server.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/geomarks/new',
    description=""" Create a new geomark from the geometries read from the 'body' parameter or file. """,
    tags=['geomark_creation'],
)
def post_geomarks_new(request: Request):
    """
    Create a new geomark
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/geomarks/{geomarkId}.{fileFormatExtension}',
    description=""" The attribution can be downloaded as a info file format. The download files can then be processed by a client application to access the geomark info fields and to get the URLs to the geometry download resources. """,
    tags=['geomark_details_access'],
)
def get_geomarks__geomark_id__file_format_extension(
    geomark_id: str = Path(..., alias='geomarkId'),
    file_format_extension: FileFormatExtension = Path(..., alias='fileFormatExtension'),
    srid: Optional[Srid] = 4326,
):
    """
    Get information about a particular geomark
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/geomarks/{geomarkId}/boundingBox.{fileFormatExtension}',
    description=""" The source geomarks can be specified by with the geomarkUrl parameter.  Repeat the parameter if sourcing from multiple geomarks """,
    tags=['geomark_details_access'],
)
def get_geomarks__geomark_id_bounding_box__file_format_extension(
    geomark_id: str = Path(..., alias='geomarkId'),
    file_format_extension: FileFormatExtension = Path(..., alias='fileFormatExtension'),
    srid: Optional[Srid] = 4326,
):
    """
    Gets the bounding box of the geomark
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/geomarks/{geomarkId}/feature.{fileFormatExtension}',
    description=""" The geomark feature resource returns a single spatial feature with either a single (Point, LineString, Polygon) or multi-part geometry (MultiPoint, MultiLineString, MultiPolygon) and the geomark attribution.  The geometry and attribution can be downloaded as a spatial download file format in a supported coordinate system. The download files can then be used in a desktop GIS application (e.g. ArcMap), Google Earth or a web mapping application. """,
    tags=['geomark_details_access'],
)
def get_geomarks__geomark_id_feature__file_format_extension(
    geomark_id: str = Path(..., alias='geomarkId'),
    file_format_extension: FileFormatExtension = Path(..., alias='fileFormatExtension'),
    srid: Optional[Srid] = 4326,
):
    """
    Get the feature and attribution of the geomark
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/geomarks/{geomarkId}/parts.{fileFormatExtension}',
    description=""" The geomark parts resource returns a one or more spatial features. One for each part of the Geomark's geomerty. Each part contains a single (Point, LineString, Polygon) geometry and the geomark attribution. """,
    tags=['geomark_details_access'],
)
def get_geomarks__geomark_id_parts__file_format_extension(
    geomark_id: str = Path(..., alias='geomarkId'),
    file_format_extension: FileFormatExtension = Path(..., alias='fileFormatExtension'),
    srid: Optional[Srid] = 4326,
):
    """
    Get the individual geometries within a multi-part geometry
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/geomarks/{geomarkId}/point.{fileFormatExtension}',
    description=""" The geomark point resource returns a single spatial feature with a single Point and the geomark attribution.  The point geometry will be created from the first geometry part of the Geomark. Point geomarks will return the first Point part in the geomark.  LineString geomarks will return the first coordinate of the first LineString part in the geomark. Polygon geomarks will return the centroid or another point inside the first Polygon part in the geomark. The geometry and attribution can be downloaded as a spatial download file format in a supported coordinate system. The download files can then be used in a desktop GIS application (e.g. ArcMap), Google Earth or a web mapping application. """,
    tags=['geomark_details_access'],
)
def get_geomarks__geomark_id_point__file_format_extension(
    geomark_id: str = Path(..., alias='geomarkId'),
    file_format_extension: FileFormatExtension = Path(..., alias='fileFormatExtension'),
    srid: Optional[Srid] = 4326,
):
    """
    Gets a single spatial point representative of the geomark.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
